/**********************************************************************
 * eBSON11 â€” BSON encoder in C++11.
 *
 * Copyright (C) 2013  Georg Rudoy		<georg@barzer.net>
 * Copyright (C) 2013  Andre Yanpolsky	<andre@barzer.net>
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#pragma once

#include <string>
#include <vector>
#include <cstring>
#include <iostream>
#include "stringnum.h"
#include "uninit_vector.h"

namespace ebson11
{
namespace detail
{
	template<typename Impl>
	struct TypeInterface
	{
	public:
		// individual value encoders
		void encode_double(double i, const char *name = 0)
		{
			static_assert(sizeof(double) == 8, "we don't support non-8-bytes-doubles yet");
			static_cast<Impl*>(this)->encode_type(i, 0x01, name);
		}

		void encode_int32(int32_t i, const char *name = 0) { static_cast<Impl*>(this)->encode_type(i, 0x10, name); }
		void encode_bool(bool i, const char *name = 0) { static_cast<Impl*>(this)->encode_type(static_cast<uint8_t>(i), 0x08, name); }

		void encode_string(const char *str, const char *name = 0)
		{
			char pre[4] = { 0 };
			const auto strlenp = static_cast<int32_t>(std::strlen(str)) + 1;

			pre[0] = strlenp & 0x000000ff;
			pre[1] = strlenp & 0x0000ff00;
			pre[2] = strlenp & 0x00ff0000;
			pre[3] = strlenp & 0xff000000;

			char post = 0;

			static_cast<Impl*>(this)->template encode_bytes<4, 1>(str, strlenp - 1, pre, &post, 0x2, name);
		}
	};
} // namespace detail

class DocumentGuard;

template<template<typename, typename> class BufType = detail::uninit_vector>
class EncoderT : public detail::TypeInterface<EncoderT<BufType>>
{
	friend struct detail::TypeInterface<EncoderT<BufType>>;
	friend class DocumentGuard;
public:
	typedef BufType<uint8_t, std::allocator<uint8_t>> BufType_t;
private:
	struct StackFrame
	{
		int32_t size = 0;			// cumulative size
		size_t sizeOffset = 0;		// &buf[sizeOffset] - size of the document

		StackFrame() {}
		StackFrame(int32_t sz, size_t szOffs) : size(sz), sizeOffset(szOffs) {}
	};
	std::vector<StackFrame> d_stk;

	BufType_t d_buf;

	void* buf_at_offset(size_t offs) { return &(d_buf[offs]); }
	void stack_increment_sz(int32_t sz) { d_stk.back().size+= sz; }

	void* new_bytes(size_t addSz)
	{
		const size_t offs = d_buf.size();
		d_buf.resize(d_buf.size() + addSz);
		return buf_at_offset(offs);
	}

	void stack_pop()
	{
		if (d_stk.empty())
			return;

		*static_cast<uint8_t*>(new_bytes(1)) = 0;
		stack_increment_sz(1);

		const int32_t sz = d_stk.back().size;

		*static_cast<int32_t*>(buf_at_offset(d_stk.back().sizeOffset)) = sz; // updating the size in the buffer
		d_stk.resize(d_stk.size() - 1);

		if (!d_stk.empty())
			d_stk.back().size += sz; // incrementing size on stack
	}

	void stack_push()
	{
		int32_t newSz = 4;
		d_stk.push_back({ newSz, d_buf.size() });
		new_bytes(sizeof(uint32_t));
	}

	int32_t encode_name(const char *n)
	{
		if (!n)
			n = "";

		const size_t addSz = std::strlen(n) +1 ;
		std::memcpy(new_bytes(addSz), n, addSz);
		return addSz;
	}

	template<typename T>
	void encode_type(T t, uint8_t typeId, const char *name)
	{
		d_buf.push_back(typeId);

		const int32_t sz = 1 + encode_name(name) + sizeof(T);
		*static_cast<T*>(new_bytes(sizeof(T))) = t;
		stack_increment_sz(sz);
	}

	template<int PreSize, int PostSize>
	void encode_bytes(const char *bytes, int32_t bytesLength,
			const char *pre, const char *post,
			uint8_t typeId, const char *name)
	{
		d_buf.push_back(typeId);

		const int32_t sumSz = 1 + encode_name(name) + PreSize + bytesLength + PostSize;

		auto mem = new_bytes(PreSize + bytesLength + PostSize);
		if (PreSize)
		{
			memcpy(mem, pre, PreSize);
			mem = static_cast<char*>(mem) + PreSize;
		}
		memcpy(mem, bytes, bytesLength);
		mem = static_cast<char*>(mem) + bytesLength;
		if (PostSize)
			std::memcpy(mem, post, PostSize);

		stack_increment_sz(sumSz);
	}
public:
	enum { DEFAULT_RESERVE_SZ = 1024*64 };

	EncoderT(size_t reserve = DEFAULT_RESERVE_SZ)
	{
		d_buf.reserve(reserve);
		stack_push();
	}

	EncoderT(const EncoderT&) = delete;
	EncoderT(EncoderT&&) = delete;

	EncoderT& operator=(const EncoderT&) = delete;
	EncoderT& operator=(EncoderT&&) = delete;

	void restart()
	{
		d_buf.resize(0);
		d_stk.clear();
		stack_push();
	}

	/** @brief Finalizes the document and returns the buffer.
	 *
	 * This function returns the reference to the buffer, potentially requiring to copy it.
	 * Please see the other finalize() overload if you worry about the performance.
	 */
	const BufType_t& finalize()
	{
		stack_pop();
		return d_buf;
	}

	/** @brief Finalizes the document and moves the buffer to \em out.
	 *
	 * This function can be used instead of the other finalize() overload to return the
	 * buffer by swapping it with another one. Swapping is cheap and doesn't induce copying,
	 * buf it destroys the contents of the encoder.
	 *
	 * restart() should be called after this method if the encoder is to be used again.
	 */
	void finalize(BufType_t& out)
	{
		stack_pop();
		d_buf.swap(out);
	}

	// document or array begin (pushes the stack)
	void document_start(bool isArr = false, const char *name = 0)
	{
		d_buf.push_back(isArr ? 0x4 : 0x3);
		d_stk.back().size += encode_name(name) + 1;
		stack_push();
	}

	// document or array end (pops the stack)
	void document_end() { stack_pop(); }
};

typedef EncoderT<> Encoder;

class DocumentGuard : public detail::TypeInterface<DocumentGuard>
{
	friend struct detail::TypeInterface<DocumentGuard>;

	Encoder& m_encoder;

	const bool m_isArr;
	StrRepDecimal m_arrIdx;

	template<typename T>
	void encode_type(T t, uint8_t typeId, const char *name)
	{
		if (!m_isArr)
			m_encoder.encode_type(t, typeId, name);
		else
		{
			m_encoder.encode_type(t, typeId, m_arrIdx.c_str());
			++m_arrIdx;
		}
	}

	template<int PreSize, int PostSize>
	void encode_bytes(const char *bytes, int32_t bytesLength,
			const char *pre, const char *post,
			uint8_t typeId, const char *name)
	{
		if (!m_isArr)
			m_encoder.encode_bytes<PreSize, PostSize>(bytes, bytesLength, pre, post, typeId, name);
		else
		{
			m_encoder.encode_bytes<PreSize, PostSize>(bytes, bytesLength, pre, post, typeId, m_arrIdx.c_str());
			++m_arrIdx;
		}
	}
public:
	DocumentGuard(const DocumentGuard&) = delete;
	DocumentGuard(DocumentGuard&&) = delete;

	DocumentGuard& operator=(const DocumentGuard&) = delete;
	DocumentGuard& operator=(DocumentGuard&&) = delete;

	DocumentGuard(Encoder& e, bool isArr = false, const char *name = 0)
	: m_encoder(e)
	, m_isArr(isArr)
	{
		m_encoder.document_start(isArr, name );
	}

	~DocumentGuard()
	{
		m_encoder.document_end();
	}
};
} // namespace ebson11
